//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.18408
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class ObjectSerializer
{
	static BindingFlags getFieldFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

	static ClassSerializer defaultSerializer = new ClassSerializer();
	static Dictionary<Type,ClassSerializer> serializers = new Dictionary<Type, ClassSerializer>()
	{
		{typeof(Transform),new TransformSerializer()},
		{typeof(Rigidbody2D),new Rigidbody2DSerializer()},
		{typeof(Animator),new AnimatorSerializer()}

	};
	class ClassSerializer{

		public virtual void Save(StringWriterEx str, object obj)
		{
			Type t = obj.GetType();

			var fields= t.GetFields(getFieldFlags).Where(f=>f.GetCustomAttributes(typeof(StoreThis),true).Length>0).ToArray();
			
			str.WriteLine(fields.Length);
			//Debug.Log("   > Class has "+fields.Length+" fields");
			foreach(FieldInfo f in fields)
			{
				str.WriteLine(f.Name);
				
				str.WriteLine(StoreBase.SaveField(f,obj));
				
			}
		}

		public virtual void Load(StringReaderEx str, object obj)
		{
			Type t = obj.GetType();

			var fields= t.GetFields(getFieldFlags).Where(f=>f.GetCustomAttributes(typeof(StoreThis),true).Length>0).ToArray();
			
			int len = str.ReadLineInt();
			if(fields.Length!=len)
				throw new UnityException("Incorrect save file");
			
			for(int i=0;i<len;i++)
			{
				string fieldName = str.ReadLine();
				string fieldData = str.ReadLine();
				
				//Debug.Log("    > Loading field "+fieldName);
				FieldInfo finfo = fields.Where(f=>f.Name==fieldName).First();
				if(finfo==null)
					continue;
				StoreBase.LoadField(finfo,obj,fieldData);
			}
		}
	}

	class TransformSerializer : ClassSerializer
	{
		public override void Save(StringWriterEx str, object obj)
		{
			Transform tr = obj as Transform;
			str.WriteLine(tr.position);
			str.WriteLine(tr.localScale);
			str.WriteLine(tr.rotation.eulerAngles);
		}

		public override void Load(StringReaderEx str, object obj)
		{
			Transform tr = obj as Transform;
			tr.position = str.ReadLineVector3();
			tr.localScale = str.ReadLineVector3();
			tr.rotation = Quaternion.Euler(str.ReadLineVector3());
		}
	}

	class Rigidbody2DSerializer : ClassSerializer
	{
		public override void Save(StringWriterEx str, object obj)
		{
			Rigidbody2D r = obj as Rigidbody2D;
			str.WriteLine(r.isKinematic);
			str.WriteLine(r.gravityScale);
		}
		
		public override void Load(StringReaderEx str, object obj)
		{
			Rigidbody2D r = obj as Rigidbody2D;
			r.isKinematic = str.ReadLineBool();
			r.gravityScale = str.ReadLineFloat();
		}
	}

	class AnimatorSerializer : ClassSerializer
	{
		public override void Save(StringWriterEx str, object obj)
		{
			Animator a = obj as Animator;
			AnimatorStateInfo s = a.GetCurrentAnimatorStateInfo(0);

			str.WriteLine(s.nameHash);
			str.WriteLine(s.normalizedTime);

		}
		
		public override void Load(StringReaderEx str, object obj)
		{
			Animator a = obj as Animator;
			a.Play(str.ReadLineInt(),0,str.ReadLineFloat());


		}
	}


	static ClassSerializer GetClassSerializer(Component c)
	{
		Type t = c.GetType();
		if(serializers.ContainsKey(t))
			return serializers[t];

		return defaultSerializer;
	}

	public static void StoreComponent(StringWriterEx str, Component c)
	{
		GetClassSerializer(c).Save(str,c);
	}

	public static void LoadComponent(StringReaderEx str, Component c)
	{
		GetClassSerializer(c).Load(str,c);

		Type t = c.GetType();

		MethodInfo[] methods = t.GetMethods(getFieldFlags).Where(i => (i.GetCustomAttributes(typeof(ExecuteAfterLoad),true).Length>0)).ToArray();

		foreach(MethodInfo m in methods)
		{
			m.Invoke(c,null);
		}
	}
	public static void StoreObject(StringWriterEx str, GameObject obj)
	{
		Component[] components = obj.GetComponents<Component>();
		
		str.WriteLine(obj.activeSelf);
		
		str.WriteLine(components.Length);
		
		
		
		foreach(Component c in components)
		{
			str.WriteLine(c.GetType().Name);
			if(c is MonoBehaviour)
				str.WriteLine((c as MonoBehaviour).enabled);
			else
				str.WriteLine("true");

			StoreComponent(str,c);
			//StoreClass<Component>(str,c);
		}
	}

	public static void LoadObject(StringReaderEx str, GameObject obj)
	{
		Component[] components = obj.GetComponents<Component>();
		Dictionary<string,Component> byName = new Dictionary<string, Component>();
		
		foreach(Component c in components)
			byName[c.GetType().Name] = c;
		
		bool isActive = str.ReadLineBool();
		
		int len = str.ReadLineInt();
		
		for(int i=0;i<len;i++)
		{
			string name = str.ReadLine();
			bool enabled = str.ReadLineBool();
			if(byName.ContainsKey(name))
			{
				Component c = byName[name];
				if(c is MonoBehaviour)
					(c as MonoBehaviour).enabled = enabled;

				LoadComponent(str,c);
				//LoadClass<Component>(str,c);
			}
		}
		
		obj.SetActive(isActive);
	}
}


